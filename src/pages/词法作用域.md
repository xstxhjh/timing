[title]: # (词法作用域)
[date]: # (2018-12-12 &nbsp; 20:18:31)
[categories]: # (词法作用域)
[description]: # (累的时候，家是你最好的归宿。)
[image]: # (https://i.loli.net/2019/09/10/mbXA1uYWaCFdi5O.jpg)

---

# 一、词法作用域是什么？

- **词法作用域**就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的。

# 二、查找标识符

## 标识符

**标识符**（Identifier）就是一个名字，用来对变量、函数、属性、参数进行命名，或者用做某些循环语句中的跳转位置的标记。

- 作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

## 遮蔽效应

- 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“**遮蔽效应**”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

- 内部的标识符"遮蔽"了外部的标识符。全局变量会自动成为全局对象（比如浏览器中 window 对象的属性），但非全局的变量如果被遮蔽了，是无论如何都无法被访问到的。

# 三、欺骗词法

在运行时修改（欺骗）词法作用域。**【欺骗词法作用域会导致性能下降】**

- **eval(..)函数**可以接受一个字符串参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。

  相似的 setTimeout(..)、setInterval(..)的第一个参数可以是字符串，字符串内容可以被解释为一段动态生成的函数。

  new Function(..)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转为动态生成的函数 ( 前面的形参是这个新生成函数的形参 )

  在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

```js
function foo(str, a) {
  eval(str) // 欺骗词法
  console.log(a, b)
}
var b = 2
foo('var b = 3;', 1) // 1 , 3
```

- **with**，JavaScript 中另一个难以掌握 ( 并且现在也不推荐使用 ) 的用来欺骗词法作用域的功能是 with 关键字。

  with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

  with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

```js
var obj = {
  a: 1,
  b: 2,
  c: 3
}

// 单调乏味的重复obj
obj.a = 2
obj.b = 3
obj.c = 4

// 简单的快捷方式
with (obj) {
  a = 3
  b = 3
  c = 3
}
```

```js
function foo(obj) {
  with (obj) {
    a = 2
  }
}
var o1 = {
  a: 3
}
var o1 = {
  b: 3
}
foo(o1)
console.log(o1.a) // 2
foo(o2)
console.log(o2.a) // undefind
console.log(a) // 2 ——不好，a被泄漏到全局作用域上了!
```

注：eval(..)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

---

- **catch**，除了 eval 与 with 之外，try-catch 语句中的 catch 子句同样可以修改执行环境的作用域链

  当 try 代码块内发生错误，执行流立即跳转到 catch 子句

  随后把异常对象推入一个可变对象并且放到作用域链最前面，这和 with 很像

  **一旦 catch 子句执行完毕，作用域链就会恢复原样**

```js
try {
  throw 2
} catch (a) {
  console.log(a) // 2
}
console.log(a) //ReferenceError: a is not defined
```

---

JavaScript 引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

在运行时才对作用域进行出行，所以如果无法明确的知道会接收到什么代码，这些代码会如何对作用域进行修改，可能导致所有的优化都是无意义的，因此最简单的做法就是完全不做任何优化。（不要使用他们）

**词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的(this 也是)。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。**